{"name":"Polynomials","tagline":"inerpolation of functions mapping to a vector space","body":"polynomials to interpolate functions\r\n====================================\r\n\r\nThis library should make it easy to construct and evaluate interpolation polynomials. Currently supported:\r\n\r\n| Feature               | syntax                                                  |\r\n|-----------------------|-------------------------------------------------------- | \r\n| construction          | `polynomial<> P( {t0,t1,t2,...,tp}, {y0,y1,y2,...,yp} )`|\r\n| evaluation            | `y =  P( time )`                                        |\r\n| differentiation       | `y =  P.deriv( time, order )`                           |\r\n| rootfinding           | `t =  P.findroot( rootfn, tlower, tupper )`             |\r\n| differentiation       | `polynomial<> deriv =  P[order]`                        |\r\n| hermite interpolation | `polynomial<> P( {t0,t0,t0,t1}, {y0,dy0,ddy0,y1} )`     |\r\n| integration           | `P.integrate( t0, t1 )`                                 |\r\n| addition/substraction | `polynomial<> sum = P1 + P2`                            |\r\n| adding points*        | `P.add_point( tnew, ynew )`                             |\r\n\r\n* * limited support for adding derivatives ( that is `tnew` already exists in `t_` )\r\n\r\nplans\r\n-----------------\r\n\r\n* automatic sorting of input, so `t_[0] <= t_[1] <= ... <= t_[p]`\r\n  * in this case `add_point` will have to insert the new point at an appropriate spot\r\n  * this requires to store all finite differences.\r\n* add spline class which stores all divided differences for dynamic order interpolation\r\n* set default the identical function for `rootfn` if `state_type` can be compared to `0`. this way, a root\r\n  of the polynomial is found","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}